#!/usr/bin/env python3
'''
    rextract - Regular expression string EXTRACTion.

    Copyright (c) 2016 Tim Savannah All Rights Reserved

    Licensed for use under terms of the Gnu General Public License (GPL) Version 3 or Later

    Running under python3 is better, you'll get better error messages from the regex engine
'''

import math
import sys
import shutil
import subprocess
import re

__version__ = '1.0.0'
__version_tuple__ = (1, 0, 0)

def getVersionInfo():
    return 'rextract version %s by Tim Savannah' %(__version__, )


def usage():
    sys.stderr.write('''Usage: rextract (Options) [reg pattern] ([Output Str])
  Reads from stdin and applies regex pattern line-by-line.

    Options:

        --debug     Enable debug mode
        --version   Print version and exit

If output str is provided, will output the variables/groups captured in the regex pattern.

Each pattern contained within parenthesis counts as a group.
Name a group like: (?P<name>.*)

Use ${1} or $1 for first group, use ${name} or $name for a name [ defined like (?P<name>.*) ]
Use ${0} or $0 for entire matched string.

NOTE: Make sure to single-quote the "output str" or escape dollar [$] signs!
''')
    sys.stderr.write('\n%s\n\n' %(getVersionInfo(), ))


# isDebug - Global "Debug" flag. Will print extra info.
isDebug = False

class MatchPrinter(object):
    '''
        MatchPrinter - Main class for dealing with matching and printing
    '''

    def __init__(self, matchStr):
        '''
            __init__ - Construct.

            @param matchStr <str> - The requested output match string (see #usage method for format).
        '''
        self.matchStr = matchStr

        self.printNames = []
        self.printGroups = []
        if matchStr:
            self.matchStr = matchStr = matchStr.replace("\\t", "\t")
            matchNames = re.findall(r'[$][\{]{0,1}(?P<name>[a-zA-Z0-9_]+)[\}]{0,1}', matchStr)
            for name in matchNames:
                if name.isdigit():
                    self.printGroups.append(int(name))
                else:
                    self.printNames.append(name)

            self.printGroups = list(set(self.printGroups))
            self.printNames = list(set(self.printNames))


    def printMatchStr(self, matchObj):
        '''
            printMatchStr - Print a match, formatted to "matchStr" as provided in __init__

            @param matchObj <SRE_Match object> - A match object
        '''

        line = matchObj.string
        matchStr = self.matchStr

        global isDebug

        if not matchStr:
            print ( line )
            return

        groupDict = matchObj.groupdict()
        orderedGroups = list(matchObj.groups())

        # Any unmatched but present keys (like entire group is in an "or" 
        #   condition within expression), replace with empty string.
        for key in groupDict:
            if groupDict[key] is None:
                groupDict[key] = ''

        for i in range(len(orderedGroups)):
            if orderedGroups[i] is None:
                orderedGroups[i] = ''

        orderedGroups = tuple(orderedGroups)

        for printGroup in self.printGroups:
            try:
                toReplace = r'[$][\{]{0,1}%d[\}]{0,1}' %(printGroup,)
                if printGroup == 0:
                    replaceWith = matchObj.string[matchObj.start() : matchObj.end()]
                else:
                    replaceWith = orderedGroups[printGroup-1]

                matchStr = re.sub(toReplace, replaceWith, matchStr)
            except Exception as e:
                if isDebug is True:
                    sys.stderr.write('DEBUG: Got exception replacing ${%d} : %s\n' %(printGroup, str(e)))


        for printName in self.printNames:
            try:
                toReplace = r'[$][\{]{0,1}%s[\}]{0,1}' %(printName, )

                if printName in groupDict:
                    replaceWith = groupDict[printName]
                else:
                    replaceWith = ''
                    if isDebug is True:
                        sys.stderr.write('DEBUG: No group found matching name: %s\n' %(printName,))

                matchStr = re.sub(toReplace, replaceWith, matchStr)

            except Exception as e:
                if isDebug is True:
                    sys.stderr.write('DEBUG: Got exception replacing ${%s} : %s\n' %(printName, str(e)))

        print ( matchStr )




def strToBlocks(toConvert, blockSize):
    '''
        strToBlocks - Split a string into blocks, of max #blockSize

        @param toConvert <str> - String to convert
        @param blockSize <int> - Max number of items per block

        @return - List of the string split up into blocks.
    '''
    ret = []
    i = 0
    lastI = 0
    toConvertLen = len(toConvert)
    if toConvertLen == 0:
        return ['']

    while i < toConvertLen:
        i += blockSize

        ret.append( toConvert[lastI : i] )

        lastI = i


    return ret


# Python3 seems to support this, and may work on windoze..
if hasattr(shutil, 'get_terminal_size'):
    def getNumColsTerminal():
        '''
            getNumColsTerminal - Gets number of columns in terminal window
        '''
        return shutil.get_terminal_size()[0]
else:
    # These only work on linux/unix systems, and probably cygwin
    def getNumColsTerminal():
        '''
            getNumColsTerminal - Gets number of columns in terminal window,
                or None if cannot determine.
        '''
        # Try tput first
        contents = None
        ret = 127
        try:
            pipe = subprocess.Popen('tput cols', shell=True, stdout=subprocess.PIPE)
            contents = pipe.stdout.read().decode('ascii')
            ret = pipe.wait()
        except:
            pass

        if ret == 0 and contents:
            return int(contents.strip())

        # Otherwise, try stty size
        contents = None
        ret = 127
        try:
            pipe = subprocess.Popen('stty size', shell=True, stdout=subprocess.PIPE)
            contents = pipe.stdout.read().decode('ascii')
            ret = pipe.wait()
        except:
            pass

        if ret == 0 and contents:
            # stty returns rows[space]cols
            return int(contents.strip().split(' ')[1])

        # Could not determine
        return None

def handleParseError(pattern, exception):
    '''
        handleParseError - Print the error, and then print the pattern
          with a caret ( ^ ) pointing at the error position.

          This only works in python3, as python2's regex engine doesn't specify an error offset

        @param pattern <str> - String of regex pattern
        @param exception <Exception> - exception raised when compiling pattern

    '''

    # On python 3 (and maybe eventually backported to 2.7, though not yet
    #  as of 2.7.12 ) the regex engine reports position of syntax error
    posRE = re.compile('.*at position (?P<pos>[\d]+)')

    exceptionMsg = str(exception)

    try:
        errorPos = int(posRE.match(exceptionMsg).groupdict()['pos'])
    except:
        # Could not extract a number, so just print error message and pattern.
        sys.stderr.write('\nERR: Cannot compile pattern: %s\n\n%s\n' %(exceptionMsg, pattern))
        return


    foundCols = getNumColsTerminal()
    if foundCols:
        numCols = foundCols
    else:
        # If we couldn't determine number of columns, assume 80.
        numCols = 80

    # Give us a little buffer room on the right
    numCols -= 4

    if numCols <= 12:
        # Some very small window here, just give up.
        sys.stderr.write('\nERR: Cannot compile pattern: %s\n\n%s\n' %(exceptionMsg, pattern))
        return


    # Split up our lines so they fit in the available columns
    blockedPattern = strToBlocks(pattern, numCols)

    # Discover which line contains the error
    lineContainingError = math.floor(errorPos / numCols)
    if float(lineContainingError) == float(errorPos) / float(numCols):
        # If this is true, we are actually on the last character of line.
        #  or, we are on the first character of the first line (hence the min)
        lineContainingError = min(lineContainingError - 1, 0)

    i = 0

    write = sys.stderr.write

    # Show error on first line
    write('\nERR: Cannot compile pattern: %s\n\n' %(exceptionMsg,))

    # Lines before the one containing error
    while i < lineContainingError:
        write(blockedPattern[i])
        write('\n')
        i += 1

    # Caret points to this upcoming line
    if errorPos == 0:
        caretPos = 0
    else:
        caretPos = errorPos % numCols
        if caretPos == 0:
            caretPos = len(blockedPattern[i])

    write(blockedPattern[i])
    write('\n')
    write(' ' * ( caretPos - 1))
    write('^')
    write('\n')

    i += 1

    # If we have lines after this, give some padding so arrow is obvious
    if i < len(blockedPattern):
        write('\n')

    # Lines after error
    while i < len(blockedPattern):
        write(blockedPattern[i])
        write('\n')
        i += 1

    write('\n')


if __name__ == '__main__':

    try:

        args = sys.argv[1:]

        if '--debug' in args:
            args.remove('--debug')
            isDebug = True

        if '--version' in args:
            sys.stderr.write('%s\n\n' %(getVersionInfo(), ))
            sys.exit(0)

        if '--help' in args or len(args) < 1:
            usage()
            sys.exit(1)

        pattern = args[0]

        # Match anywhere in the line, unless explicitly matching beginning of line
        if not pattern.startswith('^'):
            pattern = '.*' + pattern

        try:
            regex = re.compile(pattern)
        except Exception as e:
            handleParseError(pattern, e)
#            sys.stderr.write('Cannot compile pattern: "%s" (%s)\n' %(pattern, str(e)))
            sys.exit(2)

        if len(args) == 1:
            matchStr = ''
        else:
            matchStr = ' '.join(args[1:])
            if not matchStr:
                sys.stderr.write('Warning: match string provided but empty. Did you forget to use single-quotes or escape $?\n')

        matchPrinter = MatchPrinter(matchStr)

        try:
            _readline = sys.stdin.buffer.readline
            defaultEncoding = sys.getdefaultencoding()
            def readline():
                line = _readline()
                return line.decode(defaultEncoding)

        except AttributeError:
            readline = _readline = sys.stdin.readline

        line = None
        while True:
            try:
                line = readline()
            except UnicodeDecodeError as ude:
                if isDebug:
                    sys.stderr.write("Couldn't decode line: %s\n" %(str(ude),))
                continue

            if line in (b'', ''):
                break

            matchObj = regex.match(line)
            if matchObj:
                matchPrinter.printMatchStr(matchObj)

        sys.exit(0)
    except KeyboardInterrupt:
        pass
